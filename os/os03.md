OS 03
=====

-	지난시간
	-	운영체제의 정의
	-	인터럽트에 대해서
		-	SW 적?
	-	IO 병목현상 → DMA

1.5 메모리 계층구조 (Hierarchy)
-------------------------------

-	컴퓨터 메모리 :
-	특징의 트레이드-오프
	-	양, 속도, 비용 타협
	-	빠르다 → 비용 ↑ / bit
	-	용량크다 → 비용 ↓ / bit → 단가가 줄어들기에.
	-	용량크다 → 속도 ↓ / bit → 사람이 많은 거리의 비유
-	메모리 계층구조의 적용 : 단일 메모리가 아니다보니.

### 메모리 계층구조 피라미드

-	메모리 정의 (다시)
	-	저장소
	-	소용량

---

![피라미드 그림 1.14]()

-	보드 내 메모리
	1.	레지스터
	2.	캐시
	3.	주기억장치
-	보드 외 저장장치
	-	자기 디스크
	-	CD-ROM, CD-RW, DVD-RW, DVD-RAM
-	오프라인 저장장치
	-	자기 테이프
		-	과거의 오토바이가 다니던 풍경.

---

-	아래로 갈수록...
	-	비용 ↓
	-	용량 ↑
	-	접근시간 ↑ (속도 ↓)
	-	접근빈도 ↓ (지역성 ↓)

### 메모리 히트율 (적중률)

![히트율 그래프 그림 1.15]()

-	hit ratio != miss ratio
-	2단계 메모리
	-	1단계 적중시 : 1단계 → CPU (CPU가 읽어감)
	-	2단계 적중시 : 2단계 → 1단계, 1단계 → CPU (CPU가 읽어감)
-	계산
	-	`H = 0.95 → 0.95*0.1μs + 0.05*(0.1μs + 1μs(→ 2차))`
-	이런거다 만 알고 넘어갑시다

### 참조의 지역성

-	메모리의 참조는 모여있는 경향이 있음 (tend to cluster) (working set)
	-	**클러스터** : 뭉쳐있는 덩어리
	-	용어 : **Working Set** = 자주쓰는 덩어리
-	지역성이 높으면 IO 시간이 줄어듬 : 지역성을 높이면 빨라지지 않을까.
-	메모리 단계간의 교체 (swap)
	-	level 2는 전체 클러스터 (덩어리) 를 가짐
	-	때때로 level 1 → level 2 swap back : 새 클러스터(덩어리)를 level 1로 끌어오려고.

### Secondary Memory (보조 기억 장치)

-	보조(Auxiliary) 메모리
-	디스크, 테이프, 광 미디어
	-	비휘발성
	-	프로그래머에게 파일 / 블록으로 보임
-	디스크 캐시 : 메모리의 일부 : 이런 게 있다

1.6 캐시 메모리
---------------

### 왜?

![그림 1.16 캐시와 주기억장치]()

-	swap-in, swap-out 이 항상 io에서 생겨난다.
-	이상적 : CPU랑 클록 사이클이 같은 저장소만으로... → 너무 심각하게 비쌈.
-	→ 지역성 (locality) 을 활용

### 구조

![그림 1.17 캐시/주기억장치 구조]()

-	블록 단위로 집어넣는다.

### 캐시 읽기 연산

![그림 1.18 캐시 읽기 연산 순서도]()

### 캐시의 설계 / 디자인

1.	캐시 크기
2.	블록 단위 (블록 크기) 와 캐시의 trade-off
	-	블록 단위가 적으면 캐시 가능한 블록 갯수는 늘어나지만 블록당 캐시 용량은 줄어든다
3.	Mapping function (사상 함수)
	-	블록이 캐시의 어느 위치에 저장될지.
4.	교체 알고리즘 (replacement algorithm)
	-	LRU (Least-Recently-Used) : 최근에 가장 적게 쓴 거 빼내기
5.	쓰기 정책 (Write policy)
	-	중간중간 다시 주기억장치에 쓸거냐, 아님 가끔 반영할거냐.
	-	메모리에 안 쓰면 메인 메모리가 obsolate(쓸모없는) 상태가 됨. (최신이 아니므로)

1.7 입출력 통신 기술
--------------------

3가지가 있다.

-	Programmed I/O 프로그램된 입출력
-	Interrupt-driven I/O 인터럽트 구동 입출력
-	DMA : 직접 메모리 접근

### 프로그램드 I/O

무작정 기다리기. 이렇게 하지 말고...

### 인터럽트 I/O

-	쓸데없는 대기시간 줄이기
-	인터럽트
	-	PSW (Program Status Word) 에 이전 상태 저장

### DMA

인터럽트도 시간이 걸리니 그냥 다른 컨트롤러에게 맡김

부록 1A 2단계 메모리의 성능 특징
--------------------------------

-	2단계 메모리의 히트율 계산

![그림 1.24 : 상대적 메모리 크기 함수로서의 적중률]()

-	어떻게 찾아오는지 그래프적으로 표현. (슥슥 넘어감)

2장. 운영체제 개요
==================

이 책 전체의 요약본.

목차
----

-	운영체제가 뭐냐
-	어떻게 발전되었냐 : 역사
-	OS 종류 = 엄청 많다

2.1 운영체제의 목적 및 기능
---------------------------

![그림 2.1 : 컴퓨터 시스템의 계층과 관점]()

-	컴퓨터 하드웨어 (OS 설계자) → 운영체제 (프로그래머) → 유틸리티 (프로그래머) → 응용프로그램 (사용자)
-	`시장 제품은 분류가 애매한 경우가 많음`
	-	제품마다 각 카테고리를 포함하는 비율이 다를 수 있음.
-	OS
	-	인터페이스 어플리케이션 ↔ 하드웨어
	-	*특권* : 어플리케이션 프로그램의 제어권이 있는 프로그램

### OS의 목적

-	편의성 (Convenient)
-	효율성 (Efficient)
-	진화 능력 (Ability of evolve)

### OS : 인터페이스 (사용자 ↔ 컴퓨터)

-	프로그램 개발
-	**프로그램 수행**
-	입출력장치 접근
-	파일 접근 제어
-	**시스템 접근**
-	에러 발견 및 응답
-	어카운팅 (accounting) : 모니터링, 통계, 조율
	-	전산직 시스템 관리자에게, "아 컴퓨터 느려요!" → 튜닝 : 어떻게 고치는지 : 정답이 없다.
	-	중대형 시스템 → 모든 사용자에게 최적화된 성능을
	-	자원 쓴 만큼 비용 매기기

잡담 : 클라우드 컴퓨팅 → 접속해서 쓴 만큼 돈내기 → 나중에 언급.

학교에서 컴퓨터 용량을 가장 많이 쓸 때 : 입시, 수강신청, 그 외때는 팽팽 논다. → 10대 사서 팽팽 놀릴거냐? → 접속해서 쓰자 → scalable 얘긴가?

### OS : 자원 관리자

-	커널 : 운영체제중 핵심 부분. 마이크로 커널도 OS를 의미

-	자원 관리자 → 커널 (kernel)

-	![그림 2.2 자원 관리자로서 운영체제]()

---

휴식

---

### 운영체제 고려사항

-	발전의 용이성
	-	HW 업그레이드 & 새로운 형태의 HW
		-	line-at-a-time scroll terminal (???) → graphic-mode terminal
-	많은 발전이 있었다 (정도로 끝)

2.2 운영체제의 발전
-------------------

-	뭔가 역사를 잔뜩 설명해주심.
-	천공 카드
	-	OMR 카드 같은거에 줄 그어서 전산실에 준다
	-	여직원들이 그 줄에 구멍을 냄
	-	→ 하루에 컴파일 할 수 있는 시간은 두 번 뿐...
-	시간 지나서 UNIX 앞에 앉아서...
-	더 알아서 뭣하겠

### 모니터 (Monitors) : 단순 일괄처리 기법

-	초창기의 OS
-	모니터 → 작업묶음 실행, 완료→ 모니터.

### Batch Operation System : HW 기능

일정 주기로 컨텍스트 스위치.

-	메모리 보호
-	Privileged instructions
	-	![](os03-01.png)
	-	일부 명령어는 특권 명령어 → 모니터만이 수행 가능 (현재는 커널?)
	-	입출력 명령어 = 특권 명령어화됨 → 모든 I/O 장치 제어하도록
-	타이머
-	인터럽트

---

-	![그림 2.4 시스템 이용률의 예]()
	-	이용률 엄청 낮다.

#### 다중 프로그래밍 일괄처리 시스템

-	Batch 작업
	-	모아서 일괄처리하는 작업.
-	기다리는 시간이 길다 → 다중 프로그래밍
	-	![그림 2.5]()

#### 멀티프로그램된 Batch 시스템의 효과

-	작업의 분류 : bound
	-	CPU-bound Job : CPU 지향적 작업
		-	탄도 계산, 우주선의 항로 계산 등
	-	I/O-bound Job : 입출력 지향 작업
		-	멀티미디어 등
-	각 작업의 정보
	-	![표 2.1 : 샘플 프로그램의 수행 속성]()
-	활용 히스토그램 (utilization histogram)
	-	히스토그램? : 어떤 데이터의 통계치를 그림으로 표현한 것.
	-	![그림 2.6 이용률 히스토그램]
		-	→ 늘어놓으면 30분 걸릴걸 안 쓰는 자원 써서 15분만에.
		-	→ 자원의 경쟁이 없는 경우.
	-	자원의 경쟁
		-	프린터가 2개인데 두 개 인쇄하면 경쟁이 없음
		-	프린터가 한 개인데 두 개 인쇄하려면...? 경쟁!
			-	→ OS가 자원을 관리.
			-	→ 경쟁이 없으면 의미가 없다, 자원이 한정되어있기에.

### Time Sharing System (시분할 시스템)

-	시간을 1/n으로 나눈다 : 공평.
-	인터럽트 기준 : Time Slice (시간 나눔)
	-	타이머가 인터럽트 역할
-	Interleaving
	-	짧은 시간의 Time Slot → CPU를 많이 안 씀 → 즉각즉각 응답 → 자기혼자 쓴다고 생각
	-	→ 각 사용자의 실행을 동시에 중첩해서 실행할 수 있다

책 읽음. (97p)

-	시간의 흐름에 따른 메모리 나눠가지기 예제
	-	![그림 2.7 CTSS 연산]()
		-	→ 시간에 따른 작업의 메모리 상태
	-	(CTSS : MIT에서 옛날에 만든 시분할 시스템)

---

-	**preempted** - 선취, 선점 : 중요한 단어.

2.3 주요 성과
-------------

-	OS 발전에서 이루어진 주요 5 성과
	1.	프로세스
	2.	메모리 관리
	3.	정보 보호 및 보안
	4.	스케줄링 및 자원 관리
	5.	시스템구조
