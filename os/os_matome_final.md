os_matome_final
===============

---

전반적인 부분
=============

1.	운영체제란 무엇인가
2.	프로그래밍 과제 2개. 변수이름 살짝씩 바꿈, 빈칸채우기, 틀린거 고르기
	-	스레드
		-	`pthread_create( &mythread, NULL, thread_function, NULL)` // 스레드 ID 변수 (주소), 스레드 속성, 함수, 인자
		-	`pthread_join( mythread, NULL )` // 스레드 ID 변수, 종료상태 (→ PTHREAD_CANCELED 매크로?)
	-	세마포어 (p → 임계영역 → v)
		-	`int semget(key_t key, int nsems, int semflg);`
			-	`sem_id = semget((key_t)1234, 1, 0666 | IPC_CREAT);`
		-	`int semctl(int semid, int semnum, int cmd, ...);`
			-	set_semvalue()
				-	`union semun sem_union;`
				-	`sem_union.val = 1;`
				-	`if (semctl(sem_id, 0, SETVAL, sem_union) == -1) return(0);` // 실패시
			-	del_semvalue()
				-	`if (semctl(sem_id, 0, IPC_RMID, sem_union) == -1)`
		-	`int semop(int semid, struct sembuf *sops, unsigned nsops);`
			-	`struct sembuf *sops : 변경 정보의 배열 (대상, 동작, 플래그)`
			-	`semop(sem_id, &pbuf, 1)` // ← sem_num = 0, sem_op = -1, sem_flg = SEM_UNDO
			-	`semop(sem_id, &vbuf, 1)` // ← sem_num = 0, sem_op = 1, sem_flg = SEM_UNDO
	-	공유메모리 (`void * shared_memory`\)
		-	`int shmget(key_t key,  int size, int shmflg);`
			-	`shmget((key_t)1234, sizeof(struct shared_use_st), 0666 | IPC_CREAT)`
		-	`void *shmat(int shmid, const void *shmaddr, int shmflg);`
			-	`shared_memory = shmat(shmid, (void *)0, 0)` // 실패시 -1 반환
		-	`int shmdt(const void *shmaddr);` // detach
			-	`shmdt(shared_memory)`
		-	`int shmctl(int shmid, int cmd, struct shmid_ds *buf);`
			-	`shmctl(shmid, IPC_RMID, 0)` // IPC_RMID : 제거를 세그먼트에 표시함 (요청) : 마지막 프로세스가 떼어내면 제거됨

---

**4장** 스레드, SMP, 마이크로커널
=================================

1.	(216~220) 프로세스와 스레드, 정의, 특성, 비교
	-	특징
		-	자원 소유권
		-	스케줄링/수행
	-	특징 : 프로세스 vs 스레드
		-	자원 소유권 : 프로세스 (보호의 단위, 자원 할당의 범위)
		-	스케줄링/수행 : 스레드 ()
	-	상세
		-	프로세스
			-	가상 주소 공간
			-	자원 등의 접근 제어, 보호
		-	스레드
			-	스레드 수행 상태, 문맥, 수행 스택, 지역변수
				-	관점 : 독립된 프로그램 카운터
			-	메모리 및 자원은 공유 (프로세스 단위)
	-	소속 개념
	-	스레드 장점
		-	생성, 종료시간 짧음 (가볍다)
		-	정보교환, 통신 효율적 (스레드간)
	-	그림
		-	프로세스 제어블록
		-	사용자 주소공간
		-	스레드마다
			-	사용자 스택
			-	커널 스택
2.	(256~258) 윈도, 리눅스 스레드 기능 비교
	-	윈도 : 스레드와 프로세스가 명확히 구분됨 (보통의 모델)
	-	리눅스 : 프로세스가 스레드로서도 동작함 (그룹 ID 이용, clone()으로 자신을 복제하여 스레드 생성)
		-	원래는 커널 수준 스레드를 지원하지 않았음, 사용자 수준 스레드 : pthread
		-	스레드를 위한 별도의 자료구조가 없고, 프로세스의 자원을 공유할 수 있음
		-	clone()의 플래그가 없음 = fork(), clone()의 플래그로 프로세스의 공유할 부분 결정

---

**5장** 병행성 : 상호 배제와 동기화
===================================

1.	(271, 288) 5장 용어정의 (이거 쉼표같은데?)
	-	병행성이 발생하는 문맥
	-	병행성과 관련있는 주요 용어들
		-	원자적 연산 (Atomic Operation) : 단위연산. 블랙박스, 간섭, 중지 불가
		-	임계 영역 (Critical section) : 공유 자원을 접근하는 코드 영역. (딴애들이 접근 = 문제 발생)
		-	교착상태 (Deadlock) : 두 개 이상의 .가 더이상 진행을 할 수 없는 상태
		-	라이브 락 (Livelock, Busy-waiting) : CPU만 뺑뺑 도는 상황. 유익하지 않은 작업을 반복적으로 수행
		-	상호 배제 (Mutual Exclusion) : 한 순간에 한 프로세스만이 해당 자원 사용 가능 / 내가 쓰면 네가 못 쓰고, 네가 쓰면 내가 못 쓰고. / 각 프로세스들은 열심히 수행하고는 있지만, 수행하는 작업은 유용한 작업이 아닌 반복적인 상태 변화일 뿐이다.
		-	경쟁상태 (Race Condition) : 같은 걸 동시에 쓰려고 경쟁 / 두 개 이상의 프로세스가 공유 자원을 동시에 접근하려는 상태.
		-	기아상태 (Starvation) : 굶기. 스케줄링 X. 매우 오랜 기간동안 스케줄링되지 못하는 경우
	-	대표적인 병행성 기법
		-	세마포어 ()
			-	이진 세마포어
		-	뮤텍스
		-	조건 변수
		-	모니터
		-	이벤트 플래그
		-	메일박스/메시지
		-	스핀 락
2.	(286) 하드웨어 기법을 이용한 Mutual Exclusion 기법 (두 가지 라는듯)
	-	Compare & Swap 명령어
	-	Exchange 명령어
3.	(302, 303, 307) Program Pseudo-code : 세마포어, 모니터 등의 알고리즘을 구분하는 의사코드.

---

**6장** 병행성 : 교착상태와 기아상태
====================================

1.	(351~352) 데드락 발생조건 (필요, 필요충분 뭐 그런 거)
	-	필요조건
		1.	상호배제 (mutual exclusion) (공유불가) : 한 순간에 한 프로세스만이 해당 자원 사용가능
		2.	점유대기 (hold and wait) (욕심쟁이) : 이미 자원을 보유한 프로세스가 다른 자원을 요청, 기다리고 있음
		3.	비선점 (no preemption) (돚거불가) : 이미 점유된 자원을 딴 프로세스가 못 뺏음
	-	충분조건
		1.	환형대기 (서로내놔) : 프로세스간 닫힌연결 (closed chain) : 자원 할당 그래프에서 환형이 그려짐
2.	(356~360) 교착상태 회피를 위한 Banker's Algorithm(Safe?)
	-	회피 : 자원 할당은 하되 교착상태가 발생하지 않도록 (예방은 아예 1~3 중 하나를 배제함)
	-	두 가지 (프로세스 시작 거부, 자원 할당 거부)
		-	프로세스 시작 거부
		-	자원 할당 거부 (은행원 알고리즘)
3.	(367, 368, 369) 프로그램 의사 코드

---

**7장** 메모리 관리
===================

1.	(408, 411) 내부 / 외부 단편화, 정의, 문제점, 해결방법?
	-	고정 분할, 동적 분할
	-	고정 분할 (내부 단편화)
		-	내부 단편화 (internal fragmentation) : 적재되는 데이터가 파티션보다 작을 때 파티션 내부 공간의 낭비가 발생하는 현상
	-	동적 분할
		-	외부 단편화 (external fragmentation) : 적당한 데에 넣고 빼고 하다보니 작은 **구멍** 들만 다수 만들어지는 상황 (넣을데가 없다)
		-	→ 메모리 집약 (compaction) : 프로세스가 이용하는 파티션을 이동시켜서 공간 만들기 (빈 공간 모으기)
		-	배치 알고리즘 세가지 (최적, 최초, 순환)
	-	버디 시스템 (해결법 중 하나) : 반반무마니
2.	(417~418) 논리 / 물리 주소 란 무엇? 주소변환? (그림 그려가면서 설명해야)
	-	논리 주소 (logical address) : 실제 메모리 적재위치와는 다른 주소 (물리주소로 변환됨)
		-	상대주소 : 논리주소의 특별한 경우, 상대적인 주소 (특히 레지스터의 값인 경우가 많음)
	-	물리 주소 (relative address) : 주기억장치 내에서의 실제 위치
	-	상대주소 : 변환을 위한 하드웨어 장치 요구
	-	그림
		-	베이스 레지스터 + 가산기 → 경계 레지스터 | 비교기 → 데이터 혹은 운영체제로의 인터럽트
3.	(417, 418) 페이징 / 세그먼테이션 비교, 각각이 무엇인지
	-	페이징
		-	페이지와 프레임
			-	페이지 : 프로세스 조각, 균등 크기, 프레임에 저장됨
			-	프레임 (페이지 프레임) : 메모리의 조각
		-	단편화 = 외부단편화 X, 내부단편화 O, 각 프로세스의 페이지에서만 일어남
		-	페이지 테이블 : 프로세스의 프레임 위치 관리, 각 프로세스마다 하나씩 운영체제가 관리
		-	논리주소 = 페이지 번호 & 페이지 내의 오프셋 (처리기가 물리주소로 바꿈 (HW))
		-	고정 분할과 유사 : 차이 :
			-	한 프로그램이 하나 이상의 파티션을 차지할 수 있음
			-	파티션의 크기가 보다 작음
			-	반드시 연속일 필요는 없음
	-	세그멘테이션
		-	세그먼트 : 프로세스 조각, 서로 다른 크기
		-	논리주소 = 세그멘테이션 번호 & 오프셋
		-	동적분할과 유사 (차이점 : 프로그램이 하나 이상의 파티션을 차지할 수 있음)
		-	숫자 : m + n 비트가 레지스터에 : n = 세그먼트 번호 (2^n개), m : 세그먼트 주소 (2^m 최대 크기)
	-	혼합해서 쓴다

---

**8장** 가상 메모리
===================

1.	(451, 452) 페이징 시스템에서의 주소 변환은 어떻게 하는지
	-	페이지 테이블 사용
	-	메모리 관리 형식
		-	항목 : P (존재), M (수정) 비트, 추가 제어 비트, **프레임 번호**
		-	가상주소 : 페이지 번호, 오프셋
	-	계층적 페이지 테이블
	-	그림
		-	페이지 번호 + 페이지 테이블 포인터 → (페이지 프레임 번호) + 오프셋 → (물리 주소) 저장장소
2.	(461, 462) 세그멘테이션 시스템에서 주소변환은 어떻게 하는지
	-	세그멘테이션 테이블 사용
	-	메모리 관리 형식
		-	P, M, 추가 제어 비트, **세그먼트 길이, 세그먼트 베이스**
		-	가상주소 : 세그먼트 번호, 세그먼트 오프셋
	-	그림
		-	세그먼트 번호 + 세그먼트 테이블 포인터 → (세그먼트 베이스) + 오프셋 → (물리 주소)
3.	(462, 463) 페이징 + 세그멘테이션 -
	-	프로세스 → 세그먼트 테이블, 세그먼트 → 페이지 테이블
	-	그림
		-	프로그램 → 세그멘테이션 기법 → 페이징 기법 → 주기억장치
