운영체제 02
===========

복습
----

-	자원을 관리하는 것
-	리눅스는 유닉스의 오픈소스 버전

1장. 컴퓨터 시스템 개요
=======================

-	OS
	-	HW 자원을 활용 (Exploit)
		-	프로세서(들)
		-	보조 기억 장치, I/O 장치
	-	사용자들에게 서비스를 제공
	-	→ HW와 사용자간의 인터페이스

1-1. 기본 요소
--------------

-	프로세서
-	주기억장치
	-	휘발성
	-	실기억장치, 주메모리
-	입출력 (I/O) 모듈
	-	보조기억장치
	-	통신 장비
	-	터미널 (= 모니터, 디스플레이, 단말)
-	시스템 버스
	-	프로세서, I/O 장비, 메모리간 통신

---

버스 연결됨 : 5, 6번 슬라이드 예제. : 결국 운영체제가 있어야 돌아간다 : OS가 다 제어한다

---

애플의 30% 이율 이야기, 안드로이드 플랫폼 이야기,

---

### 윤곽 보기 (Top Level Components)

-	CPU, I/O 모듈, 메인 메모리
-	인쇄 오류에 관해.
-	CPU에서 기억하기
	-	현재 뭘 하고있고, 다음에 뭘 할지
		-	PC : 프로그램 카운터 : 다음에 수행할 명령어의 주소를 저장한다.
		-	IR : 명령어 레지스터 : 현재 수행중인 명령어를 저장
			-	레지스터 : CPU 옆에 붙어있는 소용량 저장소
-	I/O
	-	버퍼 : CPU 레지스터 : MBR (Memory Buffer Register) : 주소
-	메인 메모리
	-	명령어, 데이터
	-	CPU 레지스터 : MAR (Memory address register) : 주소

---

-	메모리, 버퍼의 주소
	-	메모리에 주소가 박혀있지는 않다 : 앞에서부터 순차적으로 센 것.
-	**프로그램 = 명령어 + 데이터**

1-2. 프로세서 레지스터
----------------------

### 사용자가 볼 수 있는 레지스터

-	종류
	-	데이터 레지스터
	-	주소 레지스터
		-	인덱스 레지스터
		-	세그먼트 포인터 : 메모리는 세그먼트와 오프셋으로 참조됨
			-	세그먼트 : 메모리를 단위로 조각내놓은 경우 그 조각
	-	스택 포인터 : stack top

### 제어 및 상태 레지스터

-	PC, IR
-	PSW (Program Status Word) : 프로그램 수행 상태를 담음
	-	더 얘기하면 끝이 없음 : 인터럽트 등 (슬라이드 5)

### 조건 코드 / 플래그

-	계산 결과에 의해 채워짐
	-	산술연산 : 양, 음, 0, 오버플로우 (주소크기 초과)
-	조건 분기 연산으로 검사 : (조건 분기가 목적)
-	IA-32 로 든 예제 (슬라이드 12, 13 : 6, 7쪽 강의노트)

1.3 명령어 수행 (Instruction Execution)
---------------------------------------

### 명령어

-	가져와서 (Fetch) → 실행 (Execution)
-	명령어 사이클 : 그림 1.2 (시작 - fetch - exe - halt (독일어, 종료))

### 명령어 가져오기 / 실행

-	Fetch stage
-	명령어 분류
	-	프로세서 메모리
	-	프로세서 I/O
	-	데이터 프로세싱 : 연산
	-	제어

### 상상의 기계로 예를 들기 (40 ~ 41p)

-	16비트
-	내부 CPU 레지스터
	-	PC, IR
	-	AC : 누산기 (Accumulator) : 연산 결과 임시 저장소
-	예제 (슬라이드 17, 9p 강의노트)
	-	fetch, 수행을 나눈 그림 1.4 (책 41p)

### 입출력 (I/O) 기능

-	위의 예처럼도 가능
-	DMA : Direct Memory Access
	-	→ I/O 병목현상 (Bottleneck)을 개선하기 위해 사용
	-	CPU가 책임에서 벗어남
	-	은행 갔는데 내부에서 하는 일은 안 중요하고, 밖에서 빠르게 결과가 나오는것을 원함. : 즉각적인 답을 원함
	-	발 묶고 달리기 : 병목
	-	CPU의 엄청난 발전, 그에 비해 HW가...
	-	컴퓨터 : 가져와서 사용, 쓰기 : → CPU가 아무리 빨라져도 I/O가 느리면...... → CPU를 놀리지 말자
	-	→ CPU가 개입하지 않고 I/O와 메모리가 직접 전송!
	-	→ DMA 컨트롤러

---

휴식

---

1.4 인터럽트
------------

-	영단어 : 개입하다, 방해하다, 훼방놓다
	-	컴퓨터 작업중에 예기치 않은 일이 생겨도 정상적으로 일할 수 있게 해 주는 방식.
	-	수업중에 툭 치자, 반응(서비스) 하고 하던 일로 되돌아감
	-	인터럽트가 들어오면 수행 (서비스) 하고, 원래 하던 일로 돌아감
-	인터럽트 : ...
-	인터럽트 종류 : 많다.
	-	프로그램
	-	타이머
		-	수천명이 쓰는 컴퓨터에서 CPU가 아무 일도 안 하고 그냥 돌기만 한다면?!
	-	입출력
	-	하드웨어 실패
-	트랩 이라는 용어.
-	인터럽트 : I/O 병목현상을 개선하기 위해 (7200 rpm (4ms) vs 1GHz)
	-	그림 1.5 (교재 43p)
	-	멀티프로그래밍 = 멀티태스킹 (multi-tasking)

---

#### 인터럽트가 추가된 명령어 사이클

-	그림 1.7 (교재 45p)
-	인터럽트 검사 단계가 추가 : 매 사이클마다 인터럽트를 검사.
	-	오늘날의 프로그램은 모두 인터럽트 기반 : CUI, GUI... 다 인터럽트
-	인터럽트 : 인터럽트 핸들러 루틴을 수행 (ISR, Interrupt Service Routine)
	-	루틴 : 어떤 일을 수행하는 코드
-	봉수대 통신체계의 비유 : 가만히 있는데 인터럽트를 건다
-	이렇게 보면 운영체제는 ISR의 집합?
-	contexts are saved... OS or HW

---

-	성능이 나아졌다

---

### 인터럽트 처리의 HW, SW적 단계

-	중요 : 책 47 ~ 49 쪽

### 중첩 인터럽트 (Nested)

-	nested : nested loop로 뜻 설명
-	두 가지 방식
	-	인터럽트 비활성화 (ISR 도중) : 비현실적
	-	인터럽트 우선순위 (Interrupt Priority) 를 적용
-	인터럽트 우선순위
	-	일반적으로는 숫자 크기가 작은게 우선순위가 높지만 예제는 아닌걸로.
	-	그림 1.13 (책 52p)
	-	더 중요한 인터럽트기 나타나면 하던 걸 멈추고 그 ISR을.

### 멀티 프로그래밍

-	...

### 부록 1B (77p)

-	컴퓨터에선 모두 주소로 찾아감.
-	그림 두 개 : 77, 78 쪽
-	스택
	-	LIFO
	-	여러 프로그램 (Procedure) 간의 통신을 위한 **global DB**
	-	→ 운영체제에서의 통신은 큐 등이 아니라 스택을 사용.
	-	스택프레임... (그림 1.28) 용어는 직접적으로 쓰지 않았지만 스택으로 수행된다는걸 설명
	-	ISR 처리를 위해 쓰인다
-	책에 없는 이야기 : Interrupt Vector (IVT) : 슬라이드 22를 언급 : 실제 어떤 종류의 인터럽트가 있는지를 가리키는 것.
