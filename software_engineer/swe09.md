동등분할?
=========

binSearch 코드 (606p). 실제로 해보는 것이 나을듯

-	객체를 반환
	-	→ 하나밖에 못 반환 (심지어 변수 참조로 반환도 안 됨)
	-	→ 대신 객체를 반환.
-	실제로 짜서 돌려보세요
-	→ 생각할 도구를 만든 것.

```java

class Result {
	boolean found = false;
	int index = -1;

	Result(boolean found, int index) {
		this.found = found;
		this.index = index;
	}

	Result() {

	}

	@Override
	public String toString() {
		return "found : " + found + ", index : " + index;
	}
	@Override
	public boolean equals(Object obj) {
		if (!(obj instanceof Result)) {
			return false;
		}
		Result robj = (Result) obj;
		return (this.found == robj.found) && (this.index == robj.index);
	}
}

public class BinSearch {

	public static void search ( int key, int [] elemArray, Result r) {
		int bottom = 0;
		int top = elemArray.length - 1;
		int mid;
		r.found = false;
		r.index = -1;

		while (bottom <= top) {
			mid = (top + bottom) / 2;
			if (elemArray[mid] == key) {
				r.index = mid;
				r.found = true;
				return;
			} else {
				if (elemArray[mid] < key)
					bottom = mid + 1;
				else
					top = mid - 1;
			}
		} // while
	}
}
```

```java
import static org.junit.Assert.*;

import org.junit.Test;


public class BinSearchTest {

	@Test
	public void testSearch() {
		int key = 17;
		int[] elemArray = { 17};
		Result r = new Result();

		BinSearch.search(key, elemArray, r);

		assertEquals(r, new Result(true, 0));
	}

	@Test
	public void testSearch2() {

		int[] elemArray = { 17};
		int key = 0;
		Result r = new Result();

		BinSearch.search(key, elemArray, r);

		assertEquals(r.found, false);
	}

	@Test
	public void testSearch3() {

		int[] elemArray = { 17, 21, 23, 29};
		int key = 17;
		Result r = new Result();

		BinSearch.search(key, elemArray, r);

		assertEquals(r, new Result(true, 0));
	}

	@Test
	public void testSearch4() {

		int[] elemArray = { 9, 16, 18, 30, 31, 41, 45};
		int key = 45;
		Result r = new Result();

		BinSearch.search(key, elemArray, r);

		assertEquals(r, new Result(true, 6));
	}
}
```

-	603p 동등분할
-	가운데 상자에 대해. (알고리즘이 적혀있는 603p 의 그림)
	-	코드를 보지 않고, 이거의 스펙만 보자.
-	배열과 키의 동등분할
	-	키 : 배열에 있다 / 없다
	-	배열
	-	배열의 길이가 1이다 / 2 이상이다
	-	여러 다른 배열 크기로 테스트
	-	찾는게 배열 첫번째 / 가운데 / 끝 에 있다
	-	→
	-	배열이 한 개의 값을
	-	입력 배열의 원소의 갯수가 1보다 큼
-	조건 정리표 : 그림 23.11
	-	표에 있는 데이터를 써도 되지만 직접 데이터를 만들어보자
-	블랙박스 테스트 v s 화이트박스 테스트
	-	블박 : 소스코드 내부를 보지 않고 스펙만 보고 테스트했기 때문에
	-	루틴의 인터페이스만 보고 테스트케이스를 짰음

### 23.3.3 구조시험

-	소프트웨어의 구조와 구현 지식에서 테스트를 유도 (코드 보고 테스트 짠다)
-	밑의 그림 : 이렇게 분류할 수 있다 (그림 23.12 / 23.13, 605p)
-	여기에서의 동등분할 : 소스코드를 보니 if문이 세 갈래로 나뉘어지더라
	-	코드의 갈래로 분할한다
-	동등분할은 블박 뿐만 아니라 여기저기서 테스트 용도로 쓸 수 있다
-	코드 : coverage add? 로 돌려보세요.

### 23.3.4 경로시험

-	607 page의 시험사례는 어떤 작전으로 찾은 것?
	-	→ 동등분할 (앞에 적혀있는 그거)
	-	8가지 (...몇 가지 놓쳤네...)
	-	최소 4개의 테스트케이스가 있을 것
	-	← 최소한의 테스트케이스로 코드를 모두 커버해보자 라는 접근도 가능할 것

---

휴식

---

-	프로그램 흐름도를 그리고 cyclomatic complexity 를 구하는 문제를 낼 것임.
-	앞부분에 빼먹고 온 부분의 진도를 나갈 것.
	-	(17)
	-	형상관리 (29)
	-	서비스 (31)
-	(204p?)를 잠깐만 봅시다
	-	상태 기계 모델
		-	아무 생각없이 짜다가는 안 되는 경우가 있다
		-	→ 상태 기계를 짜면 좀 더 프로그래밍이 쉬워지는 분야를 보자
-	계산기의 예제
	-	실질적으로 로직에 해당하는건 100라인도 안 됨
-	앞으로 남은 진도
	-	State Machine 으로 뭔가 해보겠다 라는 실습부분
	-	Agile은 책으로 대부분
	-	29장은 책이 부실 → 별도 강의 자료로 진도 (형상관리)
		-	안 해보면 의미가 없음
	-	31 → 책 내용도 보지만 보충자료

17장. ~~졸라 빨리 개발하기~~ 신속한 소프트웨어 개발
===================================================

-	문서 만들기가 너무 힘들다 (개고생)
	-	복잡해 : 시험 만들기 외에도 문서를 만들어야, 승인을 받아야, 고쳐라, ...
-	요구사항이 많이 변한다
	-	SI 가지 마라 : 남이 시키는 일을 하면 괴롭다
	-	애인의 이름을 감사의 글에 쓰지 마라
-	요지 : **오버헤드**가 너무 크다
	-	SW 개발은 정작 못 하고 문서개발만 헉헉헉....
-	소프트웨어 프로젝트가 망하게 하는 방법
	-	대화를 안 하면 망해요
	-	**대화를 하긴 해야하는데**
	-	WaterFall 모델은 괴롭히려는게 아니라 하고있는지 확인하려고
-	좀 더 좋은 방법이 없을까?
	-	→ 빨리 만들자
	-	Agile 프로세스
	-	SI 업체를 제외하고 현장에서 받아들이고 있음

---

-	책 426page
	-	맨날 유지보수만 하네 → 다른 회사로 갔는데 더 안 좋은 회사...
	-	→ 사실 유지보수가 비용이 더 든다
-	→ 빨리 만들자
-	신속한 소프트웨어 개발 프로세스
	-	요구 분석, 설계, 개발, 시험이 서로 중첩된 반복적인 프로세스
	-	각 증분 (increment) 이 새로운 기능을 갖는 일련의 증분들이 개발되어 설치죔
	-	전체적으로 개발되어 설치되는게 아님!
-	과제 : Swing 을 다 짜지 말고, 윈도 빌더 같은 걸 쓰세요

---

-	특징
	1.	요구분석, 설계, 구현 프로세스가 한꺼번에
	2.	시스템은 일련의 증분 으로 개발
	3.	UI는 대게 대화식으로 개발 (RAID)

---

-	장점
	1.	고객 서비스의 신속한 인도
	2.	사용자가 시스템 개발에 참여 (← ?!)

---

-	단점 : 절차적인 회사는 좀 무리일것
	1.	관리안됨 → 산출물이 안 보인다
	2.	계약문제 → 어디까지 해줘야 하는지 모르니
	3.	검증문제 → 검증 안 된 코드를 shipping
	4.	유지보수 → 누더기 코드가 된다 → 리팩토링 (깔끔하게 고치기) 을 집어넣자

---

17.1 애자일 기법
----------------

-	요구사항이 바뀔때마다 드는 그 엄청난 시간을 줄이자.
-	현장에서도 SI 빼고 점차 쓰이는 추세
-	칠판을 이용하는 방법
	-	눈에 보이는 칠판을 쓰는 법이 좋음
	-	관리하는 사람의 생명 = 스케줄 (언제나 예상보다 오래걸린다!)
-	마일스톤 : 열심히 일만 하면 안 되고, 산출물을 → 중간결과물들을 → milestone
	-	김동수가 4주 내내 놀고 마지막 3일동안 일을 하는 사태가...
	-	항상 여유있게 준비하세요?
-	커뮤니케이션을 위해 시각적인 방법을 많이 이용
-	관리자가 되면 : 무조건 스케줄부터 요구하세요

---

432p 표 : 애자일 기법의 원리 (라기보다는 특징)

| 원리                      | 설명                                                                                                                                |
|---------------------------|-------------------------------------------------------------------------------------------------------------------------------------|
| 고객 참여                 | 빨리빨리 물어봐야 하지 않겠느냐 → 고객이 옆에 있어야 : 고객과 긴밀하게 커뮤니케이션이 되어야 한다 (시간을 안 내주니 좀 비현실적...) |
| 점증적 인도               | 고객에게 준다 → 검증                                                                                                                |
| 프로세스가 아닌 사람 중심 | 자신들의 작업 방식                                                                                                                  |
| 변경을 수용               | 원래 바뀔 걸로 예상을 하시라                                                                                                        |
| 단순성의 유지             | 누더기가 되면 리팩토링.                                                                                                             |

17.2 익스트림 프로그래밍
------------------------

-	아마도 가장 잘 알려진 애자일

| 원리                             | 설명                                                                                               |
|----------------------------------|----------------------------------------------------------------------------------------------------|
| 점증적인 계획 수립               | 요구사항 대신 스토리카드 / 스토리 : 이번 릴리즈에 포함될 것들로 ← 좀 더 가볍다                     |
| 소규모 릴리즈                    | 조금씩, 자주 제공 : 최소한의 유용한 기능이 먼저 개발                                               |
| 단순한 설계                      | 미래는 생각하지 말고, 현재만 : 하루살이 설계                                                       |
| 시험 우선 개발                   | 누더기 코드 : testing이 생명                                                                       |
| 리팩토링                         | 누더기를 간결하고 체계적으로                                                                       |
| 짝 프로그래밍 (Pair Programming) | 짝을 이루어 개발 : 짜면서 바로바로 검사 / 아이디어 교환 등 이 된다                                 |
| 공동 소유권                      | 누구든지 모든것을 변경할 수 있다 : 너 왜 내꺼 고치고 난리야 => 고쳐주셔서 감사합니다 : 모두가 소유 |
| 계속적인 통합                    | 작업이 완료되자마자 전체 시스템에 통합                                                             |
| 유지할 수 있는 속도              | 초과근무해봤자 효율 안 좋아                                                                        |
| 현장의 고객                      | 요구사항을 구현팀에 전달좀...                                                                      |

-	순서? 는 읽어보세요
-	반복적인 개발의 극한
	-	증분이 대략 격주마다 고객에게 인도될수도 있다
	-	기존에 했던 거 다 테스트 : 자동화하세요
-	유연성 있는 프로그램 → 노력의 낭비다 : 현재 요구사항에 맞는 설계만
	-	→ 리팩토링을 통해 고쳐라

### 17.2.1 XP에서의 시험

-	XP에서는 시험이 무진장 중요하다
-	XP의 주요 특징 4가지 (생략)
-	시험 계획을 먼저 작성 → 묵시적으로 "기응의 인터페이스"와 "동작 명세서" 를 모두 정의

### 17.2.2 짝 프로그래밍

-	사장이 보면 화나는 것 (웃음)
-	동일한 컴퓨터에서 둘이 하세요
	-	짝이 바뀔 수 있다 → 적극적으로 바꾼다 → **커뮤니케이션**! : 강제적인 커뮤니케이션
-	예) 성격이 독특한 사람...
	-	둘이 계획 → 보통은 오해
	-	둘이 대화하고 있어도 각자 얘기하고 있는걸수도.
	-	→ 시스템 통합을 하려니 문제가 생겼다!
	-	→ 가만히 있으면 커뮤니케이션이 안 된다
	-	→ 막 채팅으로 욕하다가 조용한 가운데서 일어나서 사람을 치려고 했다
-	→ 가까히 친하게 지내야…
-	손바락이 샤바샤바 하는 사람들이 일을 더 잘한다
	-	그 과정에서 커뮤니케이션이 일어난다
	-	대부분의 문제를 일으키는 사람이 문제를 일으킨다.
-	가끔 말만 하고 일 안 하는 사람도...
	-	서구권은 실력이 후져도 문서는 잘 만든다
-	기본 프로그래밍 실력만 일단 갖추면 커뮤니케이션이 정말 중요하다

---

보강
====

-	5월 18일
-	6월 1일
-	교수님께 얘기를 하면 따로 과외수업?
