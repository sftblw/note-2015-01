test
====

-	at lecture time, 608
-	different question than tue classs

### 7.2.1 요구사항 발견

-	177p
-	요구사항을 뽑아내기
-	어떻게?
	-	책상 앞에서 탁상공론하지는 않음
		-	현장에 방문,직원 면담 등
		-	→ 예산도 얘기.
	-	인터뷰
	-	관찰 : 사람이 말 하지 않는 것들이 있음. (→ 이상하게 생각할수도 있음)
	-	면담, 시나리오, 민속학(?!),
	-	다른 요구사항 분석법 : 구조적 분석, 시스템 프로토타입
-	요구사항 관련
	-	프로토타입 : ATM : DB는 없더라도 하는 것처럼.
	-	그림과 시나리오만으로도 이해당사자에게 보여주기에 좋음
		-	→ 이해당사자를 똑똑하게 한다 -

#### 이해당사자 : ATM에 대한 시스템 이해당사자

-	// 현재의 은행 고객 → 시스템이 서비스를 받는
-	// 다른 은행의 대표 → 타 ATM의 상호사용을 동의하는
-	(생략, 교재)
-	현실을 생각해보면 쉽게 알 수 있다

> 이 아저씨가 심심해서 생각나는 걸 써놓은 게 아니라 ... 중략 .... 현실적인 걸 써놓은 ...

#### 관점

-	상호작용 관점, 간접적 관점, 도메인 관점
-	도메인 관점은 특히 잘 신경써서 추출해야.
-	초기 관점 식별하기
	-	1.~6. (179p)

#### 면담 (인터뷰)

-	방법
	1.	closed : 질문 정해짐
	2.	opened : 질문 미정, 자유 면담.
-	현실은 혼합형. (웃음)
	-	아무것도 없는 상태에서 가면 커피나 마시고 돌아오게 될 테니
	-	전문용어 쓴다 (도메인 언어, 방언)
-	면담하다가 도메인 지식 추출하는게 어려운 이유 - 여담 : 괜찮은 병원 시스템 회사 : infinite health care (시장 점유자임.)
	1.	너무 당연한 거여서 말 안 한다
-	도메인 요구사항 :
	-	잘 안 나오니까 더 신경써라
	-	기능적 / 비기능적
-	효과적인 면담자
	1.	교수님 : 성격이 좋아야 (ㅋㅋㅋㅋㅋ)
	2.	열린 마음, 선입관 X, ...
	3.	클라이언트가 생각이 없을 때 : 요구사항을 먼저 제안 혹은 프로토타입 시스템을 이용, 작업하려고 논의를 시작

#### 시나리오

-	우리는 Seq. diagram 을 썼다 : 시나리오_들_을 여럿 쓰려면
	-	여러장의 Seq. diagram 을 쓴다던가 → 어떤 게 더 좋을까
	-	Activity Diagram : 순서도... 와 매우 비슷.
-	목적
	-	시나리오를 만드는 것 자체
	-	요구사항 발견 (시나리오 만들다보면 나온다)
-	무엇이 포함되어야 하는가
	-	use-case에 포함되어야 했던것과 유사
	-	.
		1.	시나리오가 시작되었을 때 시스템과 사용자가 기대하는 것에 대한 기술
		2.	시나리오가 ... 책 183p
-	시나리오 : 스샷, 다이어그램 등으로 보충 가능 (이해 돕기)

#### 유스케이스 (Use case)

-	액터가 무엇인가요?
	-	(시스템이 운영될 때) 시스템과 (직접) 상호작용하는 모든 것. (시스템 만들때가 아닌 운영될 때)
	-	직접 : 여러분이 간접 작용하는 것들을 자주 찾기 때문에.
-	유즈케이스?
	-	유스케이스 아래에는 여러 시나리오들이!

---

7.2.2 민속학 통과. 스킵.

7.3 요구사항 검증
-----------------

1.	Validity (유효성 점검)
	-	고객이 원하는 것인지, 필요로 하는 것인지
2.	Consistency (일관성)
3.	Completeness (완전성)
	-	2, 3 : 완벽히는 안 되겠지만 빼먹지는 않도록.
4.	Realism (실현성 점검)
	-	당장, 실제로 할 수 있어요?
	-	관리가 안 되면 회사도 나도 당신도 망함
	-	잡담 : 껄끄럽고 문제가 생기는 일일수록, 일찍 가라.
		-	일주일 내에 가야? : 항상, 먼저 보고를 하라. (팀장이 생각이 있을 것)
		-	*지난달까지 왔으면 해줄 수 있었는데*
		-	쉽진 않다 : 껄끄러우면 사람이라... : 힘든 건 뒤로 미루
5.	Verificable (증명가능성)

---

-	요구사항 검증 기술
	1.	요구사항 검토
		-	항상 리스크를 생각하라 : 잘못될 수 있는 경우를 생각해보기
		-	어떻게 점검할까 : 회사원이 한다는 그 회의! : 똑같이 껄끄러운 문제들은 뒤로 미뤄진다
		-	회의를 빨리 끝내는 방법 : 서서 회의
	2.	프로토타입 만들어보기
	3.	시험 사례 생성
		-	다시 드는 예제 : 절대값 함수의 테스트 케이스 : -1, 0, 1, INT_MAX, INT_MIN
		-	그림 4.10 (109p)
		-	V 모델? : 꺾어 올린다 (v자로 그린다) : 요구사항이 나온 걸로 뒤에 테스트할 때 사용 : 연쇄.
			-	똑같은 워터폴 모델이지만 배치를 v자로 : 짝을 짓기 위해
	4.	나중에 쓰일 시험사항을 미리 만들어보는것도 괜찮은 방법이다

### 7.3.1 요구사항 검토

-	종류
	1.	증명가능성 (Verifiability)
	2.	이해용이성 (Comprehensibility)
	3.	**추적가능성 (Traceability)**
		-	추적가능성을 가지도록 요구사항을 써야.
	4.	적응가능성 (Adaptability)
		-	결합도 낮추세요, 응집도 높이세요

### 7.4.2 요구사항 관리 계획 수립

#### 추적가능성

-	추적가능성
	1.	출처 추적 (Source traceability) : 이해당사자
	2.	요구사항 추적 (Requirements traceability) : 요구사항
	3.	설계 추적 (Design traceability) : 구현된 것들
-	: 의존성 기록해놓기 → 나중에 바뀌면 의존된 것들 다 변경

---

8, 9장 스킵, 12장부터 해서 11장으로 감.

---

제 12장 . 분산 시스템 아키텍처
==============================

> SW 개발에도 봄여름가을겨울이 있는 것 같아요.
>
> 1.	처음엔 잘해봅시다 하고 봄처럼 시작
> 2.	논쟁하면서 여름이 되고
> 3.	관심이 식고 싸늘해지는 가을, 막판이 되어가니 걱정되기 시작
> 4.	된 게 없는 겨울 : 죽고 싶다던가.
>
> SW 개발이 평탄하게 진행되지만은 않음, 쥐구멍에도 볕들 날 있다
>
> 개똥밭에 굴러도 이승이 낫다 : 힘들면 레벨이 올라가고 있구나 하고 생각하세요

---

휴식

---

잡담
====

-	이론만 뛰어난 여학생들 (...여학생 아닌데 찔리네요)
-	이론과 프로젝트가 병행이 되지 않으면....

12장
====

-	분산 시스템 아키텍처가 무엇일까
	-	standalone이 아니라 서버랑 연동해서 하는 모든 것이 분산 시스템 아키텍처로 되어있을 것이다
-	디스크만 따로 분리되어있는 디스크 장치가 있다... : 독립된 디스크 장치 사용
-	전산실 제품의 제품들은 다 다를거다
-	장점
	1.	자원공유 : 디스크 분리, 용량 제약 넘기
	2.	개방성
	3.	병행성 : 네트워크상에 프로세스들이 분산되어 실행
	4.	확장성 : 구글이 계속 컴퓨터를 늘리듯이.
	5.	결함 내성 : 여러대 중 한 두대 죽어도 서비스는 계속 제공
		-	스위치 죽으면 쫄딱 망함 (웃음)
-	단점
	-	.
		1.	복잡성
		2.	보안성
		3.	관리가능성
		4.	예측불가능성
	-	외우지는 마시고. 서버를 생각해보세요
		-	요청을 분산하는 장치의 부하가 심해짐
		-	→ 많은 연구들이 이루어져있고, 필요함
	-	제일 단순한 방법 : DNS
-	아키텍처
	1.	클라이언트-서버 아키텍처 (보통)
	2.	분산 객체 아키텍처 : 나중에 설명

12.2 클라이언트-서버 아키텍처
-----------------------------

-	여기서 말하는 클라와 서버는 컴퓨터가 아니라 **프로세스**다
-	보여주는 것 : 표현 (presentation) 계층
	-	웹 브라우저의 예. 실제 처리는 프로세스, UI만 클라이언트의 브라우저에서.
-	모델 : 2단 클라이언트-서버 아키텍처
	1.	얇은 클라이언트 모델 (thin-client model)
		-	표현 계층 (Presentation layer) 만 사용자한테. → 실제 처리는 서버에서
	2.	두꺼운 클라이언트 (fat-client model)
		-	응용 처리 일부분을 클라이언트가 담당
		-	서버는 데이터만 처리
		-	캐릭터가 나타나서 그림을 그리고 칼질을 하고
-	3단 클라이언트-서버 아키텍처 (3 tier)
	-	과연 얇은 클라이언트만 많을까요
		-	: 땡
		-	왜 기능이 세 가지인데 두 가지로만 나누는가요
	-	클라이언트 ↔ 서버 (응용처리) ↔ 서버 (데이터 관리)
	-	→ 데이터와 응용 처리를 구분
	-	: Tomcat 과 mySQL이 분리되어있다는 사실

12.3 분산 객체 아키텍처
-----------------------

-	간단한 웹페이지 : JSP, 대형 웹페이지는 WAS가 좋음 → 작은 사이트는 굳이 할 필요가.
	-	오라클 WebLogic
	-	티맥스 Jeus
	-	→ 아파치 톰캣보다 더 기능이 있는 것이다
-	그림 잔뜩
-	CORBA 표준 (Spec) : 네트워크 상에 서비스를 요청.
	-	IDL (Interface Definition Language)
	-	→ 결국 망했다...

12.4 조직간의 분산 컴퓨팅
-------------------------

### 12.4.1 P2P 아키텍처 (Peer-2-Peer)

-	SETI @ Home

### 12.4.2 서비스 지향 시스템 아키텍처

-	우편번호 검색해야 하는데 엄청난 DB와 자원이 있어야 한다라면
-	→ 우편번호 서비스를 제공하는 장사가 있을 것
-	공공데이터 등 : 서울버스 등
-	316 페이지 그림 12.17
-	요즘엔 모두 XML
-	HTTP를 통해 간다
	-	왜 하필이면 소켓 통신이 아닌 웹 통신일까 → 대부분의 포트는 막아놓는다 → 일반적으로 쓰이는 포트
-	프로토콜 3가지?
	1.	SOAP
	2.	WSDL
	3.	UDD

---

-	P2P 와 웹 서비스 지향 → 시험범위 X
-	뒤에 졸았는데 잘 됐...
-	다음주 목요일 9시 50분까지 608호
-	질문 OK
